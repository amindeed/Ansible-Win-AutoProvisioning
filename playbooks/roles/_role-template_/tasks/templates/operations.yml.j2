---
- name: "Start operations.."
  meta: noop

{% for operation in setup_phase_operations %}
{% set upper_loop = loop %}

- name: "Initialization.."
  win_file:
    path: '{% raw %}{{ win_temp_dir_path }}{% endraw %}'
    state: directory

{# ▰▰▰▰▰▰▰▰▰▰▰▰ Checks ▰▰▰▰▰▰▰▰▰▰▰▰ #}

  {% if 'checks' in operation %}
    {% for check_item in operation.checks %}

{# ︵‿︵‿ Check TCP Network Flows ︵‿︵‿ #}
      {% if 'check_net_flows' in check_item %}
        {% for flow_item in check_item.check_net_flows %}

- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Check Required TCP Network flows"
  win_shell: |
    $net_test = Test-NetConnection -ComputerName {{ flow_item.target_host }} -Port {{ flow_item.target_port }}
    if($net_test.TcpTestSucceeded) {
      Write-Host "success"
    } else {
      Write-Host "failure"
    }
  register: netflow_check_result
  changed_when: false

- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Results of TCP Network flow check"
  assert:
    that:
      - "'success' in netflow_check_result.stdout"
      - "'failure' not in netflow_check_result.stdout"
    fail_msg: "Failed to establish TCP connection to '{{ flow_item.target_host }}:{{ flow_item.target_port }}'"
    success_msg: "TCP connection to '{{ flow_item.target_host }}:{{ flow_item.target_port }}' succeeded!"
  ignore_errors: {% if flow_item.abort_on_failure is defined and flow_item.abort_on_failure %}no{% else %}yes{% endif %}

        {% endfor %}
{# ︵‿︵‿︵‿︵‿ #}
      
{# ︵‿︵‿ Check HTTP Server Status ︵‿︵‿ #}
      {% elif 'check_http_status' in check_item %}
        {% for http_check_item in check_item.check_http_status %}
          {# .... #}
        {% endfor %}
{# ︵‿︵‿︵‿︵‿ #}
      

{# ︵‿︵‿ Check Windows Service Status ︵‿︵‿ #}
      {% elif 'check_service_status' in check_item %}
        {% for service_check_item in check_item.check_service_status %}
          {# .... #}
        {% endfor %}
{# ︵‿︵‿︵‿︵‿ #}


      {% endif %}
    {% endfor %}








{# ▰▰▰▰▰▰▰▰▰▰▰▰  Installations ▰▰▰▰▰▰▰▰▰▰▰▰ #}

  {% elif 'installations' in operation %}
    {% for installation_item in operation.installations %}
      {% if 'software_components' in installation_item %}
        {% for software_item in installation_item.software_components %}


- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Check '{{ software_item.software_fullname }}' status *BEFORE* installation"
  win_shell: |
    $appName = "{{ software_item.software_fullname }}"
    $wmiQuery = Get-WmiObject -Class Win32_Product | Where-Object { $_.Name -like "*$appName*" }
    $regPath1 = "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall"
    $regPath2 = "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
    $regCheck1 = Get-ChildItem -Path $regPath1 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    $regCheck2 = Get-ChildItem -Path $regPath2 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    if ($wmiQuery -or $regCheck1 -or $regCheck2) { $status = "Installed" } else { $status = "Not Installed" }
    Write-Host "$appName is $status"
  register: initial_software_status
  changed_when: false
  no_log: true

{# ︵‿︵‿ Download Packages from HTTP source ︵‿︵‿ #}

{% if software_item.upload_file is not defined and (software_item.file_full_url is defined or software_item.file_relative_url is defined) %}
- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Download '{{ software_item.software_fullname }}' files"
  win_get_url:
{% if software_item.file_full_url is defined and software_item.file_full_url is not none %}
    url: "{{ software_item.file_full_url }}"
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ software_item.file_full_url.split("/")[-1] }}'
{% elif software_item.file_relative_url is defined and software_item.file_relative_url is not none %}
    url: "{% raw %}{{ pkgs_repo_base_url }}{% endraw %}/{{ software_item.file_relative_url }}"
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ software_item.file_relative_url.split("/")[-1] }}'
{% endif %}
    url_username: "{{ software_item.http_auth_username | default('{{ http_auth_username }}') }}"
    url_password: "{{ software_item.http_auth_password | default('{{ http_auth_password }}') }}"
    timeout: 60
  when: "'Not Installed' in initial_software_status.stdout"

{% endif %} {# end process 'Download' #}


{# ︵‿︵‿ Upload packages from Ansible Controller machine ︵‿︵‿ #}
{% if software_item.upload_file is defined and software_item.upload_file is not none %}
- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Upload '{{ software_item.software_fullname }}' files to target host"
  win_copy:
    src: '{% raw %}{{ uploads_dir }}{% endraw %}/{{ software_item.upload_file }}'
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ software_item.upload_file }}'
    backup: yes
  when: "'Not Installed' in initial_software_status.stdout"
{% endif %}

{% if software_item.upload_file is defined %}
  {% set file_name = software_item.upload_file %}
{% elif software_item.file_full_url is defined %}
  {% set file_name = software_item.file_full_url.split('/')[-1] %}
{% elif software_item.file_relative_url is defined %}
  {% set file_name = software_item.file_relative_url.split('/')[-1] %}
{% endif %}

{% if software_item.type == 'bundle' %}
- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Unzip '{{ file_name }}'"
  win_unzip:
    src: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}'
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name.split(".")[0] }}'
    creates: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name.split(".")[0] }}'
  when: "'Not Installed' in initial_software_status.stdout"
{% endif %}


{% if software_item.root_install_dir is defined or root_install_dir is defined %}
- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Check custom target installation directory"
  win_file:
    path: '{{ software_item.root_install_dir | default(root_install_dir) }}'
    state: directory
  when: "'Not Installed' in initial_software_status.stdout"
{% endif %}


{% if software_item.type == 'zip' %}
- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Unzip '{{ file_name }}'"
  win_unzip:
    src: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}'
    dest: '{{ software_item.root_install_dir | default("C:\\Program Files") }}\{% if software_item.create_directory is not defined or software_item.create_directory %}{{ software_item.software_fullname }}{% endif %}'
    creates: '{{ software_item.root_install_dir | default("C:\\Program Files") }}\{{ software_item.software_fullname }}'
  when: "'Not Installed' in initial_software_status.stdout"
{% endif %}


- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Install '{{ software_item.software_fullname }}'"
  win_shell: |
    $installResult = $null
    $installSuccess = $false

{# ︵‿︵‿ Install 'msi' ︵‿︵‿ #}
{% if software_item.type == 'msi' %}
    $installResult = (Start-Process -FilePath "msiexec.exe" -ArgumentList "/i `"{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}`" {% if software_item.root_install_dir is defined %}INSTALLDIR=`"{{ software_item.root_install_dir }}\{{ software_item.install_directory_name | default(software_item.software_fullname) }}`" TARGETDIR=`"{{ software_item.root_install_dir }}\{{ software_item.install_directory_name | default(software_item.software_fullname) }}`" INSTALLLOCATION=`"{{ software_item.root_install_dir }}\{{ software_item.install_directory_name | default(software_item.software_fullname) }}`" INSTALLFOLDER=`"{{ software_item.root_install_dir }}\{{ software_item.install_directory_name | default(software_item.software_fullname) }}`" INSTALLPATH=`"{{ software_item.root_install_dir }}\{{ software_item.install_directory_name | default(software_item.software_fullname) }}`" APPLICATIONFOLDER=`"{{ software_item.root_install_dir }}\{{ software_item.install_directory_name | default(software_item.software_fullname) }}`" APPDIR=`"{{ software_item.root_install_dir }}\{{ software_item.install_directory_name | default(software_item.software_fullname) }}`" ARPINSTALLLOCATION=`"{{ software_item.root_install_dir }}\{{ software_item.install_directory_name | default(software_item.software_fullname) }}`"{% endif %} /qn {{ software_item.additional_arguments | default("") }}" -Wait -PassThru).ExitCode
    if ($installResult -eq 0) {$installSuccess = $true}

{# ︵‿︵‿ Install 'exe' ︵‿︵‿ #}
{% elif software_item.type == 'exe' %} {# Typically for common installers like NSIS #}
    try {% raw %}{{% endraw %}

      $installResult = (Start-Process -FilePath "{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}" -ArgumentList "{{ software_item.arguments | default("") }}" -Wait -PassThru).ExitCode

{# Manual registration is typically for portable software with 'exe' insatllers like 'Cygwin' #}
{% if software_item.manual_registration is defined %}
      $registryPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{{ software_item.software_fullname }}"

      # Generate uninstaller file content
      $uninstallerScriptContent = @"
    # Define the path to the folder to be deleted
    `$folderPath = Split-Path -Parent -Path `$MyInvocation.MyCommand.Path

    # Remove the read-only attribute if it is set
    if ((Get-Item `$folderPath).Attributes -band [System.IO.FileAttributes]::ReadOnly) {
        Set-ItemProperty -Path `$folderPath -Name IsReadOnly -Value `$false
    }

    # Check if shared shortcuts exist and remove them
    `$publicDesktopShortcut = `"`$env:PUBLIC\Desktop\{{ software_item.software_fullname }}*.lnk`"

    if (Test-Path -Path `$publicDesktopShortcut) {
        Remove-Item -Path `$publicDesktopShortcut -Recurse -Force
    }

    `$startBasePath = `"`$env:ALLUSERSPROFILE\Microsoft\Windows\Start Menu\Programs`"
    `$pattern = `"{{ software_item.software_fullname }}*`"

    Get-ChildItem -Path `$startBasePath -Directory -Recurse | Where-Object { `$_.Name -match `$pattern } | ForEach-Object {
        Remove-Item -Path `$_.FullName -Force -Recurse
    }

    Get-ChildItem -Path `$startBasePath -File -Recurse | Where-Object { `$_.Name -match `$pattern } | ForEach-Object {
        Remove-Item -Path `$_.FullName -Force
    }

    # Delete the folder and its contents
    Remove-Item -Path `$folderPath -Force -Recurse

    Remove-Item -Path `"$registryPath`" -Recurse -Force
    "@

      Set-Content -Path "{{ software_item.manual_registration.root_install_dir | default('C:\Program Files') }}\{{ software_item.software_fullname }}\uninstall.ps1" -Value $uninstallerScriptContent


{% if software_item.manual_registration.desktop_shortcut is defined and software_item.manual_registration.desktop_shortcut %}
      $WshShell = New-Object -ComObject WScript.Shell
      $Shortcut = $WshShell.CreateShortcut("$env:PUBLIC\Desktop\{{ software_item.software_fullname }}.lnk")
      $desktopTargetPath = '{{ software_item.manual_registration.root_install_dir | default("C:\\Program Files") }}'
      $desktopTargetPath += '\'
      $desktopTargetPath += '{{ software_item.software_fullname }}'
      $desktopTargetPath += '\'
      $desktopTargetPath += '{{ software_item.manual_registration.main_app_launcher | default("") }}'
      $Shortcut.TargetPath = $desktopTargetPath
      {% if software_item.manual_registration.shortcut_icon is defined %}$Shortcut.IconLocation = '{{ software_item.manual_registration.shortcut_icon }}'{% endif %}
      
      {% if software_item.manual_registration.shortcut_arguments is defined %}$Shortcut.Arguments = '{{ software_item.manual_registration.shortcut_arguments }}'{% endif %}

      $Shortcut.Save()

{% endif %}{% if software_item.manual_registration.startmenu_shortcut is not defined or software_item.manual_registration.startmenu_shortcut %}
      $WshShell = New-Object -ComObject WScript.Shell
      $Shortcut = $WshShell.CreateShortcut("$env:ALLUSERSPROFILE\Microsoft\Windows\Start Menu\Programs\{{ software_item.software_fullname }}.lnk")
      $startmenuTargetPath = '{{ software_item.manual_registration.root_install_dir | default("C:\\Program Files") }}'
      $startmenuTargetPath += '\'
      $startmenuTargetPath += '{{ software_item.software_fullname }}'
      $startmenuTargetPath += '\'
      $startmenuTargetPath += '{{ software_item.manual_registration.main_app_launcher | default("") }}'
      $Shortcut.TargetPath = $startmenuTargetPath
      {% if software_item.manual_registration.shortcut_icon is defined %}$Shortcut.IconLocation = '{{ software_item.manual_registration.shortcut_icon }}'{% endif %}

      {% if software_item.manual_registration.shortcut_arguments is defined %}$Shortcut.Arguments = '{{ software_item.manual_registration.shortcut_arguments }}'{% endif %}

      $Shortcut.Save()
{% endif %}

      $directoryPath = "{{ software_item.manual_registration.root_install_dir | default('C:\Program Files') }}\{{ software_item.software_fullname }}"
      $directoryInfo = Get-Item -Path $directoryPath
      $directorySize = Get-ChildItem -Path $directoryPath -Recurse | Measure-Object -Property Length -Sum
      $sizeInBytes = $directorySize.Sum
      $sizeInKB = [math]::Round($sizeInBytes / 1KB)

      $registryREGSZValues = {% raw %}@{{% endraw %}

          "DisplayName" = "{{ software_item.software_fullname }}  __Manual Install__"
          "UninstallString" = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -File `"{{ software_item.manual_registration.root_install_dir | default('C:\Program Files') }}\{{ software_item.software_fullname }}\uninstall.ps1`" -Verb RunAs"
          "DisplayVersion" = "$softwareVersion"
      }

      New-Item -Path $registryPath -Force
      foreach ($key in $registryREGSZValues.Keys) {
          Set-ItemProperty -Path $registryPath -Name $key -Value $registryREGSZValues[$key]
      }

      New-ItemProperty -Path $registryPath -Name "EstimatedSize" -Value $sizeInKB -PropertyType DWORD -Force
{% endif %} {# end of 'if' statement for sofwtare manual registration #}

      $installResult = 0
    } catch {
      $errorMessage = $_.Exception.Message
      Write-Host "ERROR: $errorMessage"
      $installResult = 1
    }
    {# "0" as exit success code; typically for common installers like NSIS #}
    # "0" as exit success code; typically for common installers like NSIS
    if ($installResult -eq 0) {$installSuccess = $true}

{# ︵‿︵‿ Install 'zip' ︵‿︵‿ #}
{% elif software_item.type == 'zip' %}
    try {% raw %}{{% endraw %}

      $mainAppLauncher = '{{ software_item.root_install_dir | default('C:\Program Files') }}'
      $mainAppLauncher += '\'
      $mainAppLauncher += '{{ software_item.software_fullname }}'
      $mainAppLauncher += '\'
      $mainAppLauncher += '{{ software_item.main_app_launcher | default("") }}'
      $softwareVersion = $((Get-Item $mainAppLauncher).VersionInfo.ProductVersion)
      
      $registryPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{{ software_item.software_fullname }}$(if($softwareVersion){' '+$softwareVersion})"

      # Generate uninstaller file content
      $uninstallerScriptContent = @"
    # Define the path to the folder to be deleted
    `$folderPath = Split-Path -Parent -Path `$MyInvocation.MyCommand.Path

    # Remove the read-only attribute if it is set
    if ((Get-Item `$folderPath).Attributes -band [System.IO.FileAttributes]::ReadOnly) {
        Set-ItemProperty -Path `$folderPath -Name IsReadOnly -Value `$false
    }

    `$publicDesktopShortcut = `"`$env:PUBLIC\Desktop\{{ software_item.software_fullname }}*.lnk`"
    `$commonStartMenuShortcut = `"`$env:ALLUSERSPROFILE\Microsoft\Windows\Start Menu\Programs\{{ software_item.software_fullname }}*.lnk`"

    # Check if shared shortcuts exist and remove them
    if (Test-Path -Path `$publicDesktopShortcut) {
        Remove-Item -Path `$publicDesktopShortcut -Recurse -Force
    }
    if (Test-Path -Path `$commonStartMenuShortcut) {
        Remove-Item -Path `$commonStartMenuShortcut -Recurse -Force
    }

    # Delete the folder and its contents
    Remove-Item -Path `$folderPath -Force -Recurse

    Remove-Item -Path `"$registryPath`" -Recurse -Force
    "@

      Set-Content -Path "{{ software_item.root_install_dir | default('C:\Program Files') }}\{{ software_item.software_fullname }}\uninstall.ps1" -Value $uninstallerScriptContent

{% if software_item.desktop_shortcut is defined and software_item.desktop_shortcut %}
      $WshShell = New-Object -ComObject WScript.Shell
      $Shortcut = $WshShell.CreateShortcut("$env:PUBLIC\Desktop\{{ software_item.software_fullname }}.lnk")
      $desktopTargetPath = '{{ software_item.root_install_dir | default("C:\\Program Files") }}'
      $desktopTargetPath += '\'
      $desktopTargetPath += '{{ software_item.software_fullname }}'
      $desktopTargetPath += '\'
      $desktopTargetPath += '{{ software_item.main_app_launcher | default("") }}'
      $Shortcut.TargetPath = $desktopTargetPath
      {% if software_item.shortcut_icon is defined %}$Shortcut.IconLocation = '{{ software_item.shortcut_icon }}'{% endif %}
      
      {% if software_item.shortcut_arguments is defined %}$Shortcut.Arguments = '{{ software_item.shortcut_arguments }}'{% endif %}

      $Shortcut.Save()

{% endif %}{% if software_item.startmenu_shortcut is not defined or software_item.startmenu_shortcut %}
      $WshShell = New-Object -ComObject WScript.Shell
      $Shortcut = $WshShell.CreateShortcut("$env:ALLUSERSPROFILE\Microsoft\Windows\Start Menu\Programs\{{ software_item.software_fullname }}.lnk")
      $startmenuTargetPath = '{{ software_item.root_install_dir | default("C:\\Program Files") }}'
      $startmenuTargetPath += '\'
      $startmenuTargetPath += '{{ software_item.software_fullname }}'
      $startmenuTargetPath += '\'
      $startmenuTargetPath += '{{ software_item.main_app_launcher | default("") }}'
      $Shortcut.TargetPath = $startmenuTargetPath
      {% if software_item.shortcut_icon is defined %}$Shortcut.IconLocation = '{{ software_item.shortcut_icon }}'{% endif %}
      
      {% if software_item.shortcut_arguments is defined %}$Shortcut.Arguments = '{{ software_item.shortcut_arguments }}'{% endif %}

      $Shortcut.Save()
{% endif %}

      $directoryPath = "{{ software_item.root_install_dir | default('C:\Program Files') }}\{{ software_item.software_fullname }}"
      $directoryInfo = Get-Item -Path $directoryPath
      $directorySize = Get-ChildItem -Path $directoryPath -Recurse | Measure-Object -Property Length -Sum
      $sizeInBytes = $directorySize.Sum
      $sizeInKB = [math]::Round($sizeInBytes / 1KB)

      $registryREGSZValues = {% raw %}@{{% endraw %}

          "DisplayName" = "{{ software_item.software_fullname }}  __Manual Install__"
{% if software_item.main_app_launcher is defined %}
          "DisplayIcon" = "{{ software_item.root_install_dir | default('C:\Program Files') }}\{{ software_item.software_fullname }}\{{ software_item.main_app_launcher }},0"
{% endif %}
          "UninstallString" = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -File `"{{ software_item.root_install_dir | default('C:\Program Files') }}\{{ software_item.software_fullname }}\uninstall.ps1`" -Verb RunAs"
          "DisplayVersion" = "$softwareVersion"
      }

      New-Item -Path $registryPath -Force
      foreach ($key in $registryREGSZValues.Keys) {
          Set-ItemProperty -Path $registryPath -Name $key -Value $registryREGSZValues[$key]
      }

      New-ItemProperty -Path $registryPath -Name "EstimatedSize" -Value $sizeInKB -PropertyType DWORD -Force

      $installResult = 0
    } catch {
      $errorMessage = $_.Exception.Message
      Write-Host "ERROR: $errorMessage"
      $installResult = 1
    }
    if ($installResult -eq 0) {$installSuccess = $true}

{# ︵‿︵‿ Install 'bundle' ︵‿︵‿ #}
{% elif software_item.type == 'bundle' %}
    Set-Location "{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name.split('.')[0] }}"
    $InstallerFile = "{{ software_item.installer_file_path }}"
    $InstArgList = "{{ software_item.arguments | default("") }}"
    $successExitCodes = @()
{% set all_exit_codes = software_item.success_exit_codes | default([0]) %}
{% for exit_code in all_exit_codes %}
    $successExitCodes += {{ exit_code }}
{% endfor %}
    $installResult = (Start-Process $InstallerFile -ArgumentList $InstArgList -Wait -PassThru -WindowStyle Hidden).ExitCode
    if ($successExitCodes -contains $installResult) {$installSuccess = $true}
{% endif %}

    if (-not $installSuccess) {
        Write-Output "{{ software_item.software_fullname }} installation failed. Exit Code: $installResult"
        exit 1 }
  register: component_install_result
  failed_when: component_install_result.rc != 0 or 'installation failed' in component_install_result.stdout
  when: "'Not Installed' in initial_software_status.stdout"


- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Check '{{ software_item.software_fullname }}' status *AFTER* installation"
  win_shell: |
    $appName = "{{ software_item.software_fullname }}"
    $wmiQuery = Get-WmiObject -Class Win32_Product | Where-Object { $_.Name -like "*$appName*" }
    $regPath1 = "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall"
    $regPath2 = "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
    $regPath3 = "HKLM:\SOFTWARE"
    $regCheck1 = Get-ChildItem -Path $regPath1 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    $regCheck2 = Get-ChildItem -Path $regPath2 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    $regCheck3 = Get-ChildItem -Path $regPath3 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    if ($wmiQuery -or $regCheck1 -or $regCheck2 -or $regCheck3) { $status = "Installed" } else { $status = "Not Installed" }
    Write-Host "$appName is $status"
  register: new_software_status
  changed_when: false
  failed_when: new_software_status.rc != 0 or 'Not Installed' in new_software_status.stdout
{# Temporarilly added to speed up the release of a first release of 'Basic Bundle' code. #}
  ignore_errors: {% if software_item.abort_on_aftercheck_failure is defined and not software_item.abort_on_aftercheck_failure %}yes{% else %}no{% endif %}
  
  when: "'Not Installed' in initial_software_status.stdout"

        {% endfor %}
      {% endif %}
    {% endfor %}







{# ▰▰▰▰▰▰▰▰▰▰▰▰ Configurations ▰▰▰▰▰▰▰▰▰▰▰▰ #}

  {% elif 'configurations' in operation %}
    {% for config_item in operation.configurations %}
      {% if 'update_resource' in config_item %}
        {% for update_item in config_item.update_resource %}



{# ︵‿︵‿︵‿︵‿ Handle System Environment Variables ︵‿︵‿︵‿︵‿ #}
{% if update_item.resource_type == 'env_var' %}
{% if update_item.resource_name|lower == 'path' %}
- name: '{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Append "{{ update_item.value }}" to "{{ update_item.resource_name }}"'
{% else %}
- name: '{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Set "{{ update_item.resource_name }}" system environment variable'
{% endif %}
  win_shell: |
    function IsVar($var) {
      if ($null -eq $var) {return $false}
      if ($var -is [string]) {return -not [string]::IsNullOrEmpty($var)}
      if ($var -is [array] -or $var -is [System.Collections.IEnumerable]) {return $var.Count -ne 0}
      return $true
    }
    try {
      $newEnvVarValue = '{{ update_item.value | default("") }}'
      $currentEnvVarValue = (Get-Item -Path "HKLM:\System\CurrentControlSet\Control\Session Manager\Environment").GetValue('{{ update_item.resource_name }}',$null,'DoNotExpandEnvironmentNames')
      $action = '{{ update_item.action | default("append") }}'

      if (IsVar $currentEnvVarValue) {
        if ($action -eq 'append') {
          #$envvarItemsList = $currentEnvVarValue -split ";"
          #$envvarContainsNewVal = $envvarItemsList -contains $newEnvVarValue

          if ($currentEnvVarValue -notlike "*$newEnvVarValue*") {
            $currentEnvVarValue += ';{{ update_item.value | default("") }}'
            #[Environment]::SetEnvironmentVariable("{{ update_item.resource_name }}", $currentEnvVarValue, [System.EnvironmentVariableTarget]::Machine)
            New-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Session Manager\Environment" -Name "{{ update_item.resource_name }}" -Value $currentEnvVarValue -PropertyType ExpandString -Force
            Write-Host "[OK_CHANGE] New value appended to system environment variable '{{ update_item.resource_name }}'."
            exit 0
          } else {
              Write-Host "[OK_NO_CHANGE] Value already in system environment variable '{{ update_item.resource_name }}'."
              exit 0
            }
        } elseif ('{{ update_item.resource_name }}' -ieq 'PATH') {
            Write-Host "[KO_FAILURE] Only 'append' action is allowed for 'PATH' environment variable."
            exit 1
        } elseif ($action -eq 'modify') {
          if ($currentEnvVarValue -eq '{{ update_item.value | default("") }}') {
            Write-Host "[OK_NO_CHANGE] '{{ update_item.resource_name }}' variable value already equals to '{{ update_item.value | default("") }}'."
            exit 0
          } else {
            [Environment]::SetEnvironmentVariable("{{ update_item.resource_name }}", $newEnvVarValue, [System.EnvironmentVariableTarget]::Machine)
            Write-Host "[OK_CHANGE] System environment variable '{{ update_item.resource_name }}' modified."
            exit 0
          }
        } elseif ($action -eq 'delete') {
          [Environment]::SetEnvironmentVariable("{{ update_item.resource_name }}", $null, [System.EnvironmentVariableTarget]::Machine)
          Write-Host "[OK_CHANGE] System environment variable '{{ update_item.resource_name }}' deleted."
          exit 0
        } elseif ($action -eq 'create')  {
          if ($currentEnvVarValue -eq '{{ update_item.value | default("") }}') {
            Write-Host "[OK_NO_CHANGE] '{{ update_item.resource_name }}' variable already exists with the value '{{ update_item.value | default("") }}'."
            exit 0
          } else {
            [Environment]::SetEnvironmentVariable("{{ update_item.resource_name }}", $newEnvVarValue, [System.EnvironmentVariableTarget]::Machine)
            Write-Host "[OK_CHANGE] '{{ update_item.resource_name }}' variable already exists, and so has been modified."
            exit 0
          }
        } else {
          Write-Host "[KO_FAILURE] unknown action '{{ update_item.action | default("") }}'."
          exit 1
        }
      } else {
        if (@('create', 'modify', 'append') -contains $action) {
          [Environment]::SetEnvironmentVariable("{{ update_item.resource_name }}", $newEnvVarValue, [System.EnvironmentVariableTarget]::Machine)
          Write-Host "[OK_CHANGE] System environment variable '{{ update_item.resource_name }}' created."
          exit 0
        } else {
          Write-Host "[OK_NO_CHANGE] '{{ update_item.resource_name }}' system environment variable does not exist."
          exit 0
        }
      }
    } catch {
      $errorMessage = $_.Exception.Message
      Write-Host "Unexpected exception/error: $errorMessage"
      exit 1
    }
  register: envvar_handling_result
  changed_when: envvar_handling_result.rc == 0 and 'OK_CHANGE' in envvar_handling_result.stdout
  failed_when: envvar_handling_result.rc != 0 or 'KO_FAILURE' in envvar_handling_result.stdout
  ignore_errors: {% if update_item.abort_on_failure is defined and update_item.abort_on_failure %}no{% else %}yes{% endif %}

{# ︵‿︵‿︵‿︵‿ Handle Registry Keys & Properties ︵‿︵‿︵‿︵‿ #}
{% elif update_item.resource_type == 'registry' %}
{#
.... 
#}

{# ︵‿︵‿︵‿︵‿ Handle Files & Directories Operations ︵‿︵‿︵‿︵‿ #}

{% elif update_item.resource_type == 'file_system' %}

{# ︵‿︵‿︵‿︵‿ Handle Files & Directories Operations: Shortcut ︵‿︵‿︵‿︵‿ #}
{% if update_item.operation_type == 'shortcut' %}
- name: '{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Create shortcut to "{{ update_item.source }}"'
  win_shortcut:
    src: '{{ update_item.source }}'
    dest: '{{ update_item.destination }}'
{% if update_item.icon is defined %}
    icon: '{{ update_item.icon }}'
{% endif %}

{# ︵‿︵‿︵‿︵‿ Handle Files & Directories Operations: Transfer ︵‿︵‿︵‿︵‿ #}
{% elif update_item.operation_type == 'transfer' %}

{% if update_item.source.upload_file is defined %}
  {% set file_name = update_item.source.upload_file.split('/')[-1] | default(update_item.source.upload_file) %}
{% elif update_item.source.file_full_url is defined %}
  {% set file_name = update_item.source.file_full_url.split('/')[-1] %}
{% elif update_item.source.file_relative_url is defined %}
  {% set file_name = update_item.source.file_relative_url.split('/')[-1] %}
{% endif %}

{# ︵‿︵‿ Download Packages from HTTP source ︵‿︵‿ #}
{% if update_item.source.upload_file is not defined and (update_item.source.file_full_url is defined or update_item.source.file_relative_url is defined) %}

{% if update_item.destination is defined %}
- name: '{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Ensure destination "{{ update_item.destination }}" exists'
  win_file: 
    path: '{{ update_item.destination }}'
    state: directory
  register: win_file_dest_check
{% endif %}

- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Download '{{ file_name }}'"
  win_get_url:
{% if update_item.source.file_full_url is defined and update_item.source.file_full_url is not none %}
    url: "{{ update_item.source.file_full_url }}"
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}'
{% elif update_item.source.file_relative_url is defined and update_item.source.file_relative_url is not none %}
    url: "{% raw %}{{ pkgs_repo_base_url }}{% endraw %}/{{ update_item.source.file_relative_url }}"
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}'
{% endif %}
    url_username: "{{ update_item.source.http_auth_username | default('{{ http_auth_username }}') }}"
    url_password: "{{ update_item.source.http_auth_password | default('{{ http_auth_password }}') }}"
    timeout: 60
  register: auth_dl_result

{% endif %} {# end process 'Download' #}

{# ︵‿︵‿ Upload files from Ansible Controller machine ︵‿︵‿ #}
{% if update_item.source.upload_file is defined and update_item.source.upload_file is not none %}

- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Upload '{{ file_name }}' to target host"
  win_copy:
    src: '{% raw %}{{ uploads_dir }}{% endraw %}/{{ update_item.source.upload_file }}'
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}'
    #backup: yes
{% endif %}

{# Down/Upload: Unzip file if 'unzip: yes' #}

{#{% if update_item.destination is not defined %}
- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Unzip '{{ file_name }}' to user-defined destination"
  fail:
    msg: "Destination not set by the user."

{% else %} #}

{% if update_item.unzip is defined and update_item.unzip %}
- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Unzip '{{ file_name }}' to user-defined destination (overwritten upon user-set configuration)"
  win_unzip:
    src: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}'
    dest: '{{ update_item.destination }}'
    {% if (update_item.overwrite_dest is defined and not update_item.overwrite_dest) or update_item.skip_if_path_exists is defined %}creates: '{{ update_item.skip_if_path_exists | default(update_item.destination) }}'{% endif %}

  when: "not win_file_dest_check.changed"

- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Unzip '{{ file_name }}' to user-defined destination (empty target dir.)"
  win_unzip:
    src: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}'
    dest: '{{ update_item.destination }}'
  when: "win_file_dest_check.changed"
{% else %} {# regular file transfer #}

{% if update_item.destination is defined and update_item.destination != win_temp_dir_path %}
- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Copy '{{ file_name }}' to user-defined destination"
  win_copy:
    src: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}'
    dest: '{{ update_item.destination }}'
    remote_src: yes
{% endif %}
{% endif %}

{# ︵‿︵‿︵‿︵‿ Handle Files & Directories Operations: Move/Rename ︵‿︵‿︵‿︵‿ #}
{% elif update_item.operation_type == 'move' %}
- name: '{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Move/Rename "{{ update_item.source }}"'
  win_shell: |
    try {
        if (Test-Path -Path "{{ update_item.source }}") {
            Move-Item -Path "{{ update_item.source }}" -Destination "{{ update_item.destination }}"
            Write-Output "[OK_CHANGE] Item moved/renamed."
            exit 0
        } else {
            Write-Output "[OK_NO_CHANGE] Item does not exist."
            exit 0
        }
    } catch {
        Write-Output "[KO_FAILURE] $_"
        exit 1
    }
  register: move_op_result
  changed_when: move_op_result.rc == 0 and 'OK_CHANGE' in move_op_result.stdout
  failed_when: move_op_result.rc != 0 or 'KO_FAILURE' in move_op_result.stdout
  ignore_errors: {% if update_item.abort_on_failure is not defined or update_item.abort_on_failure %}no{% else %}yes{% endif %}
  
{# ︵‿︵‿︵‿︵‿ Handle Files & Directories Operations: Create ︵‿︵‿︵‿︵‿ #}
{% elif update_item.operation_type == 'create' %}
{% if update_item.source is not defined and update_item.destination is defined %}
- name: '{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Create directory "{{ update_item.destination }}"'
  win_file:
    path: {{ update_item.destination }}
    state: directory

{% else %}
- name: '{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Create file "{{ update_item.destination }}"'
  win_shell: |
    try {
      $ErrorActionPreference = "Stop"

      Function New-TemporaryDirectory 
      {
          $parent = [System.IO.Path]::GetTempPath()
          $name = [System.IO.Path]::GetRandomFileName()
          New-Item -ItemType Directory -Path (Join-Path $parent $name)
      }

      $fileContent = @"
{{ update_item.source.file_text_content | indent(width=4, indentfirst=True) }}    "@
{#{{ update_item.source.file_text_content | indent(width=4, first=True) }}    "@#}

      $tempdir = New-TemporaryDirectory | Select-Object -ExpandProperty FullName
      Set-Content -Path "$tempdir\temp_file.tmp" -Value $fileContent
      $fileContentHash = Get-FileHash -Algorithm MD5 -LiteralPath "$tempdir\temp_file.tmp"

      if (-not(Test-Path -Path "{{ update_item.destination }}") -or ($fileContentHash.Hash -ne $(Get-FileHash -Algorithm MD5 -Path "{{ update_item.destination }}").Hash)) {
        Set-Content -Path "{{ update_item.destination }}" -Value $fileContent
        Write-Output "[OK_CHANGE] File created."
        Remove-Item -Recurse -Force $tempdir > $null
        exit 0
      } else {
        Write-Output "[OK_NO_CHANGE] File already exists with the exact content."
        Remove-Item -Recurse -Force $tempdir > $null
        exit 0
      }
    } catch {
      Write-Output "[KO_FAILURE] ERROR: $_.Exception.Message"
      Remove-Item -Recurse -Force $tempdir > $null
      exit 1
    }
  register: file_create_result
  changed_when: file_create_result.rc == 0 and 'OK_CHANGE' in file_create_result.stdout
  failed_when: file_create_result.rc != 0 or 'KO_FAILURE' in file_create_result.stdout
{% endif  %}

{# ︵‿︵‿︵‿︵‿ Handle Files & Directories Operations: Remove ︵‿︵‿︵‿︵‿ #}
{% elif update_item.operation_type == 'remove' %}
- name: '{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Remove "{{ update_item.destination }}"'
  win_file:
    path: {{ update_item.destination }}
    state: absent

{# ︵‿︵‿︵‿︵‿ Handle Files & Directories Operations: Append ︵‿︵‿︵‿︵‿ #}
{% elif update_item.operation_type == 'append' %}

- name: '{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Append text content to "{{ update_item.destination }}"'
  win_shell: |
    try {
      $ErrorActionPreference = "Stop"

      function IsBinary {
      # Checks for ASCII NUL Byte or UTF-8 Overlong, and returns 'True' (i.e the file is binary) if they exist
      # Inspired from: https://stackoverflow.com/questions/1077634/powershell-search-script-that-ignores-binary-files
      # Limited to supporting files less than 2 gigabytes in size.

          param(
              [string]$filePath
          )

          # Read the file as a byte array
          $fileBytes = [System.IO.File]::ReadAllBytes($filePath)

          # Function to check for ASCII NUL byte
          function ContainsNullByte($bytes) {
              foreach ($byte in $bytes) {
                  if ($byte -eq 0) {
                      return $true
                  }
              }
              return $false
          }

          # Function to check for UTF-8 overlong sequences
          function ContainsOverlongUTF8($bytes) {
              $index = 0
              while ($index -lt $bytes.Length) {
                  $byte = $bytes[$index]

                  if ($byte -le 0x7F) {
                      # ASCII character, continue
                      $index++
                  } elseif ($byte -ge 0xC0 -and $byte -le 0xDF) {
                      # 2-byte sequence
                      if ($index + 1 -ge $bytes.Length -or $bytes[$index + 1] -lt 0x80 -or $bytes[$index + 1] -gt 0xBF) {
                          return $true
                      }
                      $index += 2
                  } elseif ($byte -ge 0xE0 -and $byte -le 0xEF) {
                      # 3-byte sequence
                      if ($index + 2 -ge $bytes.Length -or $bytes[$index + 1] -lt 0x80 -or $bytes[$index + 1] -gt 0xBF -or $bytes[$index + 2] -lt 0x80 -or $bytes[$index + 2] -gt 0xBF) {
                          return $true
                      }
                      $index += 3
                  } elseif ($byte -ge 0xF0 -and $byte -le 0xF4) {
                      # 4-byte sequence
                      if ($index + 3 -ge $bytes.Length -or $bytes[$index + 1] -lt 0x80 -or $bytes[$index + 1] -gt 0xBF -or $bytes[$index + 2] -lt 0x80 -or $bytes[$index + 2] -gt 0xBF -or $bytes[$index + 3] -lt 0x80 -or $bytes[$index + 3] -gt 0xBF) {
                          return $true
                      }
                      $index += 4
                  } else {
                      return $true
                  }
              }
              return $false
          }

          # Check for NUL byte
          $containsNullByte = ContainsNullByte($fileBytes)

          # Check for overlong UTF-8 sequences
          $containsOverlongUTF8 = ContainsOverlongUTF8($fileBytes)

          return ($containsNullByte -or $containsOverlongUTF8)
      }

      if ((Test-Path -Path "{{ update_item.destination }}" -PathType Leaf) -and -not (IsBinary "{{ update_item.destination }}")) {

        $contentToAdd = @"
{{ update_item.source.file_text_content | indent(width=4, indentfirst=True) }}    "@
{#{{ update_item.source.file_text_content | indent(width=4, first=True) }}    "@#}
        Add-Content -Path "{{ update_item.destination }}" -Value $contentToAdd
        Write-Output "[OK_CHANGE] Content appended."
        exit 0
      } else {
        $errorMessage = "'{{ update_item.destination }}' is either non-existent or not a text file."
        throw [System.Exception]::new($errorMessage)
      }
    } catch {
      Write-Output "[KO_FAILURE] ERROR: $_.Exception.Message"
      exit 1
    }
  register: append_content_result
  changed_when: append_content_result.rc == 0 and 'OK_CHANGE' in append_content_result.stdout
  failed_when: append_content_result.rc != 0 or 'KO_FAILURE' in append_content_result.stdout




{# ....
- modify/move/rename
  - Modify: overwrite content, append content, find [text matching pattern] and replace

- create
  - source
    - template

- modify
  - type
    - empty
    - insert
    - find_replace
    - append
    - prepend

.... #}

{% endif %}
{% endif %}


        {% endfor %}
      {% endif %}
    {% endfor %}



{# ▰▰▰▰▰▰▰▰▰▰▰▰ Executions ▰▰▰▰▰▰▰▰▰▰▰▰ #}

  {% elif 'executions' in operation %}
    {% for exec_item in operation.executions %}

{# ︵‿︵‿︵‿︵‿ Run PowerShell Scripts ︵‿︵‿︵‿︵‿ #}
      {% if 'run_ps1_script' in exec_item %}
        {% for job_item in exec_item.run_ps1_script %}


{% if job_item.script_content | default("") == "" %} {# X #}
{% if job_item.file_full_url is defined or job_item.file_relative_url is defined %} {# XX #}
{% set file_url = job_item.file_full_url | default(job_item.file_relative_url) %}

- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Download \"{{ file_url.split('/')[-1] }}\""
  win_get_url:
{% if job_item.file_full_url is defined and job_item.file_full_url is not none %}
    url: "{{ job_item.file_full_url }}"
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ job_item.file_full_url.split("/")[-1] }}'
{% elif job_item.file_relative_url is defined and job_item.file_relative_url is not none %}
    url: "{% raw %}{{ pkgs_repo_base_url }}{% endraw %}/{{ job_item.file_relative_url }}"
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ job_item.file_relative_url.split("/")[-1] }}'
{% endif %}
    url_username: "{{ job_item.http_auth_username | default('{{ http_auth_username }}') }}"
    url_password: "{{ job_item.http_auth_password | default('{{ http_auth_password }}') }}"

{% endif %} {# XX #}
{% endif %} {# X #}

{% if job_item.working_directory is defined and job_item.working_directory is not none %}
- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Check provided working directory for script execution"
  win_file:
    path: '{{ job_item.working_directory }}'
    state: directory
{% endif %}

{% if job_item.script_content is defined %}
- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Run user-provided script ({{ job_item.description | default('') }})"
  win_shell: |
{{ job_item.script_content | indent(width=4, indentfirst=True) }}
{#{{ job_item.script_content | indent(width=4, first=True) }}#}
{% else %}
- name: "{{ label }} ({{ upper_loop.index }}/{{ upper_loop.length }}) Run the script \"{{ file_url.split('/')[-1] }}\""
  win_shell: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_url.split("/")[-1] }} {{ job_item.arguments | default("") }}'
{% if job_item.working_directory is defined and job_item.working_directory is not none %}
  args:
    chdir: {{ job_item.working_directory }}
{% endif %}
{% endif %}
  register: script_result
  changed_when: script_result.rc == 0 and 'OK_CHANGE' in script_result.stdout
  failed_when: script_result.rc != 0 or 'KO_FAILURE' in script_result.stdout
  ignore_errors: {% if job_item.abort_on_failure is defined and job_item.abort_on_failure %}no{% else %}yes{% endif %}
    
        {% endfor %}
{# ︵‿︵‿︵‿︵‿ #}
      
{# ︵‿︵‿ Run Executable Files ︵‿︵‿ #}
      {% elif 'run_executable' in exec_item %}
        {% for job_item in exec_item.run_executable %}
          {# .... #}
        {% endfor %}
{# ︵‿︵‿︵‿︵‿ #}

      {% endif %}
    {% endfor %}



{# ▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰▰ #}
  {% endif %}
{% endfor %}