---
- name: "{{ label }} Init."
  win_file:
    path: '{% raw %}{{ win_temp_dir_path }}{% endraw %}'
    state: directory


{% for item in components %}

- name: "{{ label }} ({{ loop.index }}/{{ loop.length }}) Check '{{ item.software_fullname }}' status *BEFORE* installation"
  win_shell: |
    $appName = "{{ item.software_fullname }}"
    $wmiQuery = Get-WmiObject -Class Win32_Product | Where-Object { $_.Name -like "*$appName*" }
    $regPath1 = "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall"
    $regPath2 = "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
    $regCheck1 = Get-ChildItem -Path $regPath1 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    $regCheck2 = Get-ChildItem -Path $regPath2 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    if ($wmiQuery -or $regCheck1 -or $regCheck2) { $status = "Installed" } else { $status = "Not Installed" }
    Write-Host "$appName is $status"
  register: initial_software_status
  changed_when: false
  no_log: true

{# ︵‿︵‿ Download Packages from HTTP source ︵‿︵‿ #}
{% if item.upload_file is not defined and (item.file_full_url is defined or item.file_relative_url is defined) %}
- name: "{{ label }} ({{ loop.index }}/{{ loop.length }}) Check if HTTP authentication is required for file download"
  win_shell: |
{% if item.file_full_url is defined and item.file_full_url is not none %}
    $url = "{{ item.file_full_url }}"
{% elif item.file_relative_url is defined and item.file_relative_url is not none %}
    $url = "{% raw %}{{ pkgs_repo_base_url }}{% endraw %}/{{ item.file_relative_url }}"
{% endif %}
    $responseStatusCode = $(try { Invoke-WebRequest -Uri $url -Method Head -UseBasicParsing | % {$_.StatusCode} } catch {$_.Exception.Response.StatusCode.Value__})

    if ($responseStatusCode -eq 401) { 
        Write-Host "Auth required" 
    } else { 
        Write-Host "Auth not required" 
    }
  register: auth_check
  changed_when: false
  no_log: true
  when: "'Not Installed' in initial_software_status.stdout"


- name: "{{ label }} ({{ loop.index }}/{{ loop.length }}) Download '{{ item.software_fullname }}' files (with authentication)"
  win_get_url:
{% if item.file_full_url is defined and item.file_full_url is not none %}
    url: "{{ item.file_full_url }}"
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ item.file_full_url.split("/")[-1] }}'
{% elif item.file_relative_url is defined and item.file_relative_url is not none %}
    url: "{% raw %}{{ pkgs_repo_base_url }}{% endraw %}/{{ item.file_relative_url }}"
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ item.file_relative_url.split("/")[-1] }}'
{% endif %}
    username: "{{ item.http_auth_username | default('{{ http_auth_username }}') }}"
    password: "{{ item.http_auth_password | default('{{ http_auth_password }}') }}"
  when: "'Not Installed' in initial_software_status.stdout and 'Auth required' in auth_check.stdout"


- name: "{{ label }} ({{ loop.index }}/{{ loop.length }}) Download '{{ item.software_fullname }}' files (without authentication)"
  win_get_url:
{% if item.file_full_url is defined and item.file_full_url is not none %}
    url: "{{ item.file_full_url }}"
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ item.file_full_url.split("/")[-1] }}'
{% elif item.file_relative_url is defined and item.file_relative_url is not none %}
    url: "{% raw %}{{ pkgs_repo_base_url }}{% endraw %}/{{ item.file_relative_url }}"
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ item.file_relative_url.split("/")[-1] }}'
{% endif %}
  when: "'Not Installed' in initial_software_status.stdout and 'Auth not required' in auth_check.stdout"

{% endif %} {# end process 'Download' #}


{# ︵‿︵‿ Upload packages from Ansible Controller machine ︵‿︵‿ #}
{% if item.upload_file is defined and item.upload_file is not none %}
- name: "{{ label }} ({{ loop.index }}/{{ loop.length }}) Upload '{{ item.software_fullname }}' files to target host"
  win_copy:
    src: '{% raw %}{{ uploads_dir }}{% endraw %}/{{ item.upload_file }}'
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ item.upload_file }}'
    backup: yes
  when: "'Not Installed' in initial_software_status.stdout"
{% endif %}

{% if item.upload_file is defined %}
  {% set file_name = item.upload_file %}
{% elif item.file_full_url is defined %}
  {% set file_name = item.file_full_url.split('/')[-1] %}
{% elif item.file_relative_url is defined %}
  {% set file_name = item.file_relative_url.split('/')[-1] %}
{% endif %}

{% if item.type == 'bundle' %}
- name: "{{ label }} ({{ loop.index }}/{{ loop.length }}) Unzip '{{ file_name }}'"
  win_unzip:
    src: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}'
    dest: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name.split(".")[0] }}'
    creates: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name.split(".")[0] }}'
  when: "'Not Installed' in initial_software_status.stdout"
{% endif %}


{% if item.root_install_dir is defined or root_install_dir is defined %}
- name: "{{ label }} ({{ loop.index }}/{{ loop.length }}) Check custom target installation directory"
  win_file:
    path: '{{ item.root_install_dir | default(root_install_dir) }}'
    state: directory
  when: "'Not Installed' in initial_software_status.stdout"
{% endif %}


{% if item.type == 'zip' %}
- name: "{{ label }} ({{ loop.index }}/{{ loop.length }}) Unzip '{{ file_name }}'"
  win_unzip:
    src: '{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}'
    dest: '{{ item.root_install_dir | default("C:\\Program Files") }}\{{ item.software_fullname }}'
    creates: '{{ item.root_install_dir | default("C:\\Program Files") }}\{{ item.software_fullname }}'
  when: "'Not Installed' in initial_software_status.stdout"
{% endif %}


- name: "{{ label }} ({{ loop.index }}/{{ loop.length }}) Install '{{ item.software_fullname }}'"
  win_shell: |
    $installResult = $null
    $installSuccess = $false

{# ︵‿︵‿ Install 'msi' ︵‿︵‿ #}
{% if item.type == 'msi' %}
    $installResult = (Start-Process -FilePath "msiexec.exe" -ArgumentList "/i `"{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}`" {% if item.root_install_dir is defined %}INSTALLDIR=`"{{ item.root_install_dir }}\{{ item.software_fullname }}`" TARGETDIR=`"{{ item.root_install_dir }}\{{ item.software_fullname }}`" INSTALLLOCATION=`"{{ item.root_install_dir }}\{{ item.software_fullname }}`" INSTALLFOLDER=`"{{ item.root_install_dir }}\{{ item.software_fullname }}`" INSTALLPATH=`"{{ item.root_install_dir }}\{{ item.software_fullname }}`" APPLICATIONFOLDER=`"{{ item.root_install_dir }}\{{ item.software_fullname }}`" APPDIR=`"{{ item.root_install_dir }}\{{ item.software_fullname }}`" ARPINSTALLLOCATION=`"{{ item.root_install_dir }}\{{ item.software_fullname }}`"{% endif %} /qn" -Wait -PassThru).ExitCode
    if ($installResult -eq 0) {$installSuccess = $true}

{# ︵‿︵‿ Install 'exe' ︵‿︵‿ #}
{% elif item.type == 'exe' %} {# Typically for common installer like NSIS #}
    $installResult = (Start-Process -FilePath "{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name }}" -ArgumentList "{{ item.arguments | default("") }}" -Wait -PassThru).ExitCode
    {# "0" as exit success code; typically for common installers like NSIS #}
    # "0" as exit success code; typically for common installers like NSIS
    if ($installResult -eq 0) {$installSuccess = $true}

{# ︵‿︵‿ Install 'zip' ︵‿︵‿ #}
{% elif item.type == 'zip' %}
    try {% raw %}{{% endraw %}
      $softwareVersion = $((Get-Item '{{ item.root_install_dir | default("C:\\Program Files") }}\{{ item.software_fullname }}\{{ item.main_app_launcher | default("") }}').VersionInfo.ProductVersion)
      
      $registryPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{{ item.software_fullname }}$(if($softwareVersion){' '+$softwareVersion})"

      # Generate uninstaller file content
      $uninstallerScriptContent = @"
    # Define the path to the folder to be deleted
    `$folderPath = Split-Path -Parent -Path `$MyInvocation.MyCommand.Path

    # Remove the read-only attribute if it is set
    if ((Get-Item `$folderPath).Attributes -band [System.IO.FileAttributes]::ReadOnly) {
        Set-ItemProperty -Path `$folderPath -Name IsReadOnly -Value `$false
    }

    # Delete the folder and its contents
    Remove-Item -Path `$folderPath -Force -Recurse

    `$publicDesktopShortcut = [System.Environment]::ExpandEnvironmentVariables(`"%PUBLIC%\Desktop\{{ item.software_fullname }}.lnk`")
    `$commonStartMenuShortcut = [System.Environment]::ExpandEnvironmentVariables(`"%ALLUSERSPROFILE%\Microsoft\Windows\Start Menu\Programs\{{ item.software_fullname }}.lnk`")

    # Check if shared shortcuts exist and remove them
    if (Test-Path -Path `$publicDesktopShortcut) {
        Remove-Item -Path `$publicDesktopShortcut -Force
    }
    if (Test-Path -Path `$commonStartMenuShortcut) {
        Remove-Item -Path `$commonStartMenuShortcut -Force
    }
    Remove-Item -Path `"$registryPath`" -Recurse -Force
    "@

      Add-Content "{{ item.root_install_dir | default('C:\Program Files') }}\{{ item.software_fullname }}\uninstall.ps1" $uninstallerScriptContent

{% if item.desktop_shortcut is defined and item.desktop_shortcut %}
      $WshShell = New-Object -ComObject WScript.Shell
      $Shortcut = $WshShell.CreateShortcut([System.Environment]::ExpandEnvironmentVariables("%PUBLIC%\Desktop\{{ item.software_fullname }}.lnk"))
      $Shortcut.TargetPath = '{{ item.root_install_dir | default("C:\\Program Files") }}\{{ item.software_fullname }}\{{ item.main_app_launcher | default("") }}'
      $Shortcut.Save()
{% endif %}

{% if item.startmenu_shortcut is not defined or item.startmenu_shortcut %}
      $WshShell = New-Object -ComObject WScript.Shell
      $Shortcut = $WshShell.CreateShortcut([System.Environment]::ExpandEnvironmentVariables("%ALLUSERSPROFILE%\Microsoft\Windows\Start Menu\Programs\{{ item.software_fullname }}.lnk"))
      $Shortcut.TargetPath = '{{ item.root_install_dir | default("C:\\Program Files") }}\{{ item.software_fullname }}\{{ item.main_app_launcher | default("") }}'
      $Shortcut.Save()
{% endif %}

      # Calculate sofwtare directory content size
      $directoryPath = "{{ item.root_install_dir | default('C:\Program Files') }}\{{ item.software_fullname }}"
      $directoryInfo = Get-Item -Path $directoryPath
      $directorySize = Get-ChildItem -Path $directoryPath -Recurse | Measure-Object -Property Length -Sum
      $sizeInBytes = $directorySize.Sum
      $sizeInKB = [math]::Round($sizeInBytes / 1KB)

      $registryREGSZValues = {% raw %}@{{% endraw %}
          "DisplayName" = "{{ item.software_fullname }}  __Manual Install__"
{% if item.main_app_launcher is defined %}
          "DisplayIcon" = "{{ item.root_install_dir | default('C:\Program Files') }}\{{ item.software_fullname }}\{{ item.main_app_launcher }},0"
{% endif %}
          "UninstallString" = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -File `"{{ item.root_install_dir | default('C:\Program Files') }}\{{ item.software_fullname }}\uninstall.ps1`" -Verb RunAs"
          "DisplayVersion" = "$softwareVersion"
      }

      New-Item -Path $registryPath -Force
      foreach ($key in $registryREGSZValues.Keys) {
          Set-ItemProperty -Path $registryPath -Name $key -Value $registryREGSZValues[$key]
      }

      New-ItemProperty -Path $registryPath -Name "EstimatedSize" -Value $sizeInKB -PropertyType DWORD -Force

      $installResult = 0
    } catch {
      $errorMessage = $_.Exception.Message
      Write-Host "ERROR: $errorMessage"
      $installResult = 1
    }
    if ($installResult -eq 0) {$installSuccess = $true}

{# ︵‿︵‿ Install 'bundle' ︵‿︵‿ #}
{% elif item.type == 'bundle' %}
    Set-Location "{% raw %}{{ win_temp_dir_path }}{% endraw %}\{{ file_name.split('.')[0] }}"
    $InstallerFile = "{{ item.installer_file_path }}"
    $InstArgList = "{{ item.arguments | default("") }}"
    $successExitCodes = @()
{% set all_exit_codes = item.success_exit_codes | default([0]) %}
{% for exit_code in all_exit_codes %}
    $successExitCodes += {{ exit_code }}
{% endfor %}
    $installResult = (Start-Process $InstallerFile -ArgumentList $InstArgList -Wait -PassThru -WindowStyle Hidden).ExitCode
    if ($successExitCodes -contains $installResult) {$installSuccess = $true}
{% endif %}

    if (-not $installSuccess) {
        Write-Output "{{ item.software_fullname }} installation failed. Exit Code: $installResult"
        exit 1 }
  register: component_install_result
  failed_when: component_install_result.rc != 0 or 'installation failed' in component_install_result.stdout
  when: "'Not Installed' in initial_software_status.stdout"


- name: "{{ label }} ({{ loop.index }}/{{ loop.length }}) Check '{{ item.software_fullname }}' status *AFTER* installation"
  win_shell: |
    $appName = "{{ item.software_fullname }}"
    $wmiQuery = Get-WmiObject -Class Win32_Product | Where-Object { $_.Name -like "*$appName*" }
    $regPath1 = "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall"
    $regPath2 = "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
    $regPath3 = "HKLM:\SOFTWARE"
    $regCheck1 = Get-ChildItem -Path $regPath1 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    $regCheck2 = Get-ChildItem -Path $regPath2 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    $regCheck3 = Get-ChildItem -Path $regPath3 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    if ($wmiQuery -or $regCheck1 -or $regCheck2 -or $regCheck3) { $status = "Installed" } else { $status = "Not Installed" }
    Write-Host "$appName is $status"
  register: new_software_status
  changed_when: false
  failed_when: new_software_status.rc != 0 or 'Not Installed' in new_software_status.stdout
  when: "'Not Installed' in initial_software_status.stdout"

{% endfor %}
