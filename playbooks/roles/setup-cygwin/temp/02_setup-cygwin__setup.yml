---
- name: "Start operations.."
  meta: noop


- name: "Initialization.."
  win_file:
    path: '{{ win_temp_dir_path }}'
    state: directory


                    




  

- name: '[SETUP] (1/2) Check if HTTP auth. is required to download "cygwin64install.zip"'
  win_shell: |
    $url = "{{ pkgs_repo_base_url }}/cygwin/cygwin64install.zip"
    $responseStatusCode = $(try { Invoke-WebRequest -Uri $url -Method Head -UseBasicParsing | % {$_.StatusCode} } catch {$_.Exception.Response.StatusCode.Value__})

    if ($responseStatusCode -eq 401) { 
        Write-Host "Auth required" 
    } else { 
        Write-Host "Auth not required" 
    }
  register: auth_check
  changed_when: false
  no_log: true

- name: '[SETUP] (1/2) Ensure destination "D:\AppServ\Cygwin\cygwin64install\" exists'
  win_file: 
    path: 'D:\AppServ\Cygwin\cygwin64install\'
    state: directory
  register: win_file_dest_check

- name: "[SETUP] (1/2) Download 'cygwin64install.zip' (with authentication)"
  win_get_url:
    url: "{{ pkgs_repo_base_url }}/cygwin/cygwin64install.zip"
    dest: '{{ win_temp_dir_path }}\cygwin64install.zip'
    username: "{{ http_auth_username }}"
    password: "{{ http_auth_password }}"
  register: auth_dl_result
  when: "'Auth required' in auth_check.stdout"


- name: "[SETUP] (1/2) Download 'cygwin64install.zip' (without authentication)"
  win_get_url:
    url: "{{ pkgs_repo_base_url }}/cygwin/cygwin64install.zip"
    dest: '{{ win_temp_dir_path }}\cygwin64install.zip'
  register: no_auth_dl_result
  when: "'Auth not required' in auth_check.stdout"

 

- name: "[SETUP] (1/2) Unzip 'cygwin64install.zip' to user-defined destination"
  win_unzip:
    src: '{{ win_temp_dir_path }}\cygwin64install.zip'
    dest: 'D:\AppServ\Cygwin\cygwin64install\'
    creates: 'D:\AppServ\Cygwin\cygwin64install\'
  when: "not win_file_dest_check.changed"

- name: "[SETUP] (1/2) [ALWAYS OVERWRITE DEST.] Unzip 'cygwin64install.zip' to user-defined destination"
  win_unzip:
    src: '{{ win_temp_dir_path }}\cygwin64install.zip'
    dest: 'D:\AppServ\Cygwin\cygwin64install\'
  when: "win_file_dest_check.changed"




                  



  
- name: "Initialization.."
  win_file:
    path: '{{ win_temp_dir_path }}'
    state: directory


                    

- name: "[SETUP] (2/2) Check 'Cygwin' status *BEFORE* installation"
  win_shell: |
    $appName = "Cygwin"
    $wmiQuery = Get-WmiObject -Class Win32_Product | Where-Object { $_.Name -like "*$appName*" }
    $regPath1 = "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall"
    $regPath2 = "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
    $regCheck1 = Get-ChildItem -Path $regPath1 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    $regCheck2 = Get-ChildItem -Path $regPath2 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    if ($wmiQuery -or $regCheck1 -or $regCheck2) { $status = "Installed" } else { $status = "Not Installed" }
    Write-Host "$appName is $status"
  register: initial_software_status
  changed_when: false
  no_log: true

- name: "[SETUP] (2/2) Check if HTTP authentication is required for file download"
  win_shell: |
    $url = "{{ pkgs_repo_base_url }}/cygwin/setup-x86_64.exe"
    $responseStatusCode = $(try { Invoke-WebRequest -Uri $url -Method Head -UseBasicParsing | % {$_.StatusCode} } catch {$_.Exception.Response.StatusCode.Value__})

    if ($responseStatusCode -eq 401) { 
        Write-Host "Auth required" 
    } else { 
        Write-Host "Auth not required" 
    }
  register: auth_check
  changed_when: false
  no_log: true
  when: "'Not Installed' in initial_software_status.stdout"


- name: "[SETUP] (2/2) Download 'Cygwin' files (with authentication)"
  win_get_url:
    url: "{{ pkgs_repo_base_url }}/cygwin/setup-x86_64.exe"
    dest: '{{ win_temp_dir_path }}\setup-x86_64.exe'
    username: "{{ http_auth_username }}"
    password: "{{ http_auth_password }}"
  when: "'Not Installed' in initial_software_status.stdout and 'Auth required' in auth_check.stdout"


- name: "[SETUP] (2/2) Download 'Cygwin' files (without authentication)"
  win_get_url:
    url: "{{ pkgs_repo_base_url }}/cygwin/setup-x86_64.exe"
    dest: '{{ win_temp_dir_path }}\setup-x86_64.exe'
  when: "'Not Installed' in initial_software_status.stdout and 'Auth not required' in auth_check.stdout"

 


  


- name: "[SETUP] (2/2) Check custom target installation directory"
  win_file:
    path: 'D:\AppServ'
    state: directory
  when: "'Not Installed' in initial_software_status.stdout"




- name: "[SETUP] (2/2) Install 'Cygwin'"
  win_shell: |
    $installResult = $null
    $installSuccess = $false

     try {
      $installResult = (Start-Process -FilePath "{{ win_temp_dir_path }}\setup-x86_64.exe" -ArgumentList "--quiet-mode --local-install --local-package-dir D:\AppServ\Cygwin\cygwin64install --root D:\AppServ\Cygwin\cygwin64 --no-shortcuts --packages libpopt-common,terminfo,tzdata,cygwin-devel,w32api-headers,windows-default-manifest,libsource-highlight-common,publicsuffix-list-dafsa,libgsasl-common,gsettings-desktop-schemas,cygwin,libiconv2,libintl8,w32api-runtime,libintl-devel,libncursesw10,libreadline7,bash,libzstd1,crypto-policies,base-cygwin,zlib0,libpng16,libgpg-error0,libpcre1,libidn12,libjbig2,libdeflate0,libXdmcp6,libXau6,libwebp7,liblcms2_2,libbrotlicommon1,libnghttp2_14,libidn2_0,libntlm0,libkrb5support0,libedit0,cygrunsrv,libpkgconf4,libsqlite3_0,m4,libatomic1,libiconv,gettext,libxxhash0,libexpat1,libcrypt2,libltdl7,libffi8,libunistring5,which,vim-minimal,tzcode,sed,run,ncurses,mintty,login,libtasn1_6,libsmartcols1,libsigsegv2,libpopt0,libpipeline1,libpcre2_8_0,liblzma5,liblz4_1,libgmp10,libgcc1,libffi6,libbz2_1,libattr1,libargp,ipc-utils,hostname,gzip,editrights,diffutils,dash,binutils,alternatives,libgcrypt20,libxcb1,libwebpmux3,libwebpdemux2,libbrotlidec1,libk5crypto3,pkgconf,libtool,libpsl5,cygutils,less,grep,libxml2,xz,libisl23,libjpeg8,libcom_err2,libquadmath0,libgomp1,perl_base,libgc1,libuuid1,libstdc++6,libmpfr6,libgdbm6,libp11-kit0,file,bzip2,coreutils,getent,rebase,info,_autorebase,libfreetype6,pkg-config,libglib2.0_0,desktop-file-utils,libkrb5_3,libimagequant0,libguile3.0_1,libblkid1,libgraphite2_3,libtiff6,libdb5.3,libicu61,libncurses++w10,zstd,libuchardet0,libmpc3,gawk,libgdbm_compat4,p11-kit-trust,p11-kit,findutils,gamin,libfam0,libgssapi_krb5_2,make,libfdisk1,libboost_regex1.66,libncurses-devel,tar,groff,gcc-core,csih,perl,ca-certificates,base-files,shared-mime-info,libgsasl18,util-linux,libsource-highlight4,gcc-g++,autoconf2.1,perl-JSON-PP,libssl3,libssl1.1,libharfbuzz0,libfribidi0,man-db,perl_autorebase,openssl,libsasl2_3,libssh2_1,libfido2,python39,python39-platformdirs,python39-setuptools,rsync,libraqm0,autoconf2.7,autoconf2.5,texinfo,perl-TermReadKey,perl-Error,libopenldap2,openssh,python39-iniconfig,python39-six,python39-idna,python39-toml,python39-pluggy,python39-babel,python39-markupsafe,python39-snowballstemmer,python39-imagesize,python39-olefile,python39-chardet,autoconf,libopenldap2_4_2,libcurl4,python39-urllib3,python39-jinja2,automake1.9,automake1.16,automake1.13,automake1.12,automake1.11,automake1.10,automake1.14,automake1.15,git,python39-requests,python39-pyparsing,automake,python39-packaging,python39-pytest,python39-imaging,python39-pygments,python39-docutils,python39-sphinx,python39-pip,python39-sphinxcontrib-serializinghtml,python3,gdb,gettext-devel,libsodium-common,xxd,libsodium23,vim-common,vim" -Wait -PassThru).ExitCode

      $registryPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Cygwin"

      # Generate uninstaller file content
      $uninstallerScriptContent = @"
    # Define the path to the folder to be deleted
    `$folderPath = Split-Path -Parent -Path `$MyInvocation.MyCommand.Path

    # Remove the read-only attribute if it is set
    if ((Get-Item `$folderPath).Attributes -band [System.IO.FileAttributes]::ReadOnly) {
        Set-ItemProperty -Path `$folderPath -Name IsReadOnly -Value `$false
    }

    # Check if shared shortcuts exist and remove them
    `$publicDesktopShortcut = `"`$env:PUBLIC\Desktop\Cygwin*.lnk`"

    if (Test-Path -Path `$publicDesktopShortcut) {
        Remove-Item -Path `$publicDesktopShortcut -Recurse -Force
    }

    `$startBasePath = `"`$env:ALLUSERSPROFILE\Microsoft\Windows\Start Menu\Programs`"
    `$pattern = `"Cygwin*`"

    Get-ChildItem -Path `$startBasePath -Directory -Recurse | Where-Object { `$_.Name -match `$pattern } | ForEach-Object {
        Remove-Item -Path `$_.FullName -Force -Recurse
    }

    Get-ChildItem -Path `$startBasePath -File -Recurse | Where-Object { `$_.Name -match `$pattern } | ForEach-Object {
        Remove-Item -Path `$_.FullName -Force
    }

    # Delete the folder and its contents
    Remove-Item -Path `$folderPath -Force -Recurse

    Remove-Item -Path `"$registryPath`" -Recurse -Force
    "@

      Set-Content -Path "D:\AppServ\Cygwin\uninstall.ps1" -Value $uninstallerScriptContent


      $WshShell = New-Object -ComObject WScript.Shell
      $Shortcut = $WshShell.CreateShortcut("$env:PUBLIC\Desktop\Cygwin.lnk")
      $desktopTargetPath = 'D:\AppServ'
      $desktopTargetPath += '\'
      $desktopTargetPath += 'Cygwin'
      $desktopTargetPath += '\'
      $desktopTargetPath += 'cygwin64\bin\mintty.exe'
      $Shortcut.TargetPath = $desktopTargetPath
      $Shortcut.IconLocation = 'D:\AppServ\Cygwin\cygwin64\Cygwin.ico'      
      $Shortcut.Arguments = '-i /Cygwin-Terminal.ico -'
      $Shortcut.Save()

      $WshShell = New-Object -ComObject WScript.Shell
      $Shortcut = $WshShell.CreateShortcut("$env:ALLUSERSPROFILE\Microsoft\Windows\Start Menu\Programs\Cygwin.lnk")
      $startmenuTargetPath = 'D:\AppServ'
      $startmenuTargetPath += '\'
      $startmenuTargetPath += 'Cygwin'
      $startmenuTargetPath += '\'
      $startmenuTargetPath += 'cygwin64\bin\mintty.exe'
      $Shortcut.TargetPath = $startmenuTargetPath
      $Shortcut.IconLocation = 'D:\AppServ\Cygwin\cygwin64\Cygwin.ico'
      $Shortcut.Arguments = '-i /Cygwin-Terminal.ico -'
      $Shortcut.Save()





      $directoryPath = "D:\AppServ\Cygwin"
      $directoryInfo = Get-Item -Path $directoryPath
      $directorySize = Get-ChildItem -Path $directoryPath -Recurse | Measure-Object -Property Length -Sum
      $sizeInBytes = $directorySize.Sum
      $sizeInKB = [math]::Round($sizeInBytes / 1KB)

      $registryREGSZValues = @{
          "DisplayName" = "Cygwin  __Manual Install__"
          "UninstallString" = "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -File `"D:\AppServ\Cygwin\uninstall.ps1`" -Verb RunAs"
          "DisplayVersion" = "$softwareVersion"
      }

      New-Item -Path $registryPath -Force
      foreach ($key in $registryREGSZValues.Keys) {
          Set-ItemProperty -Path $registryPath -Name $key -Value $registryREGSZValues[$key]
      }

      New-ItemProperty -Path $registryPath -Name "EstimatedSize" -Value $sizeInKB -PropertyType DWORD -Force
 
      $installResult = 0
    } catch {
      $errorMessage = $_.Exception.Message
      Write-Host "ERROR: $errorMessage"
      $installResult = 1
    }
        # "0" as exit success code; typically for common installers like NSIS
    if ($installResult -eq 0) {$installSuccess = $true}


    if (-not $installSuccess) {
        Write-Output "Cygwin installation failed. Exit Code: $installResult"
        exit 1 }
  register: component_install_result
  failed_when: component_install_result.rc != 0 or 'installation failed' in component_install_result.stdout
  when: "'Not Installed' in initial_software_status.stdout"


- name: "[SETUP] (2/2) Check 'Cygwin' status *AFTER* installation"
  win_shell: |
    $appName = "Cygwin"
    $wmiQuery = Get-WmiObject -Class Win32_Product | Where-Object { $_.Name -like "*$appName*" }
    $regPath1 = "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall"
    $regPath2 = "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
    $regPath3 = "HKLM:\SOFTWARE"
    $regCheck1 = Get-ChildItem -Path $regPath1 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    $regCheck2 = Get-ChildItem -Path $regPath2 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    $regCheck3 = Get-ChildItem -Path $regPath3 | Where-Object { $_.GetValue("DisplayName") -like "*$appName*" }
    if ($wmiQuery -or $regCheck1 -or $regCheck2 -or $regCheck3) { $status = "Installed" } else { $status = "Not Installed" }
    Write-Host "$appName is $status"
  register: new_software_status
  changed_when: false
  failed_when: new_software_status.rc != 0 or 'Not Installed' in new_software_status.stdout
  ignore_errors: no  
  when: "'Not Installed' in initial_software_status.stdout"

                  







  